<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://www.cs.york.ac.uk/fp/darcs/hscolour/ -->
<title>Haskell code</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
Bass Diffusion Model*
===

"The model describes a product diffusion process. Potential adopters
of a product are inflenced into buying the product by advertising
and by word of mouth from adopters -- those who have already
purchased the new product. Adoption of a new product driven by
word of mouth is likewise an epidemic. Potential adopters come into
contact with adopters through social interactions. A fraction of these
contacts results in the purchase of the new product. The advertising
causes a constant fraction of the potential adopter population to
adopt each time period."

The source of this implementation is
[David Sorokin's work](http://hackage.haskell.org/package/aivika-0.1).
You will find David Sorokin's original work at <https://github.com/dsorokin/aivika>

Commented it to better see the flow of implementation and the
approach of ABM taken.

If you want to read the comments, begin with the `main` function.
To try the simulation simply `:load` this file in ghci and run `main`.

<pre><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>Random</span>
<span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Array</span>
<span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Monad</span>
<span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Monad</span><span class='hs-varop'>.</span><span class='hs-conid'>Trans</span>
</pre>
<pre><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>Simulation</span><span class='hs-varop'>.</span><span class='hs-conid'>Aivika</span><span class='hs-varop'>.</span><span class='hs-conid'>Dynamics</span>
</pre>
The number of agents `n`:

<pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>n</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>500</span>
</pre>
<pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>advertisingEffectiveness</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>0.011</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>contactRate</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>100.0</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>adoptionFraction</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>0.015</span>
</pre>
<pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>specs</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Specs</span> <span class='hs-layout'>{</span> <span class='hs-varid'>spcStartTime</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>0.0</span><span class='hs-layout'>,</span>
</pre>
Eight time points:

<pre><span class='hs-varop'>&gt;</span>                 <span class='hs-varid'>spcStopTime</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>8.0</span><span class='hs-layout'>,</span>
</pre>
Ten steps between each two time points:

<pre><span class='hs-varop'>&gt;</span>                 <span class='hs-varid'>spcDT</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>0.1</span><span class='hs-layout'>,</span>
</pre>
Applying a 4th order Runge-Kutta method:

<pre><span class='hs-varop'>&gt;</span>                 <span class='hs-varid'>spcMethod</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RungeKutta4</span> <span class='hs-layout'>}</span>
</pre>
One of two Random Number Generators:

<pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>exprnd</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Double</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>Double</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>exprnd</span> <span class='hs-varid'>lambda</span> <span class='hs-keyglyph'>=</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-keyword'>do</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getStdRandom</span> <span class='hs-varid'>random</span>
<span class='hs-varop'>&gt;</span>      <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-comment'>-</span> <span class='hs-varid'>log</span> <span class='hs-varid'>x</span> <span class='hs-varop'>/</span> <span class='hs-varid'>lambda</span><span class='hs-layout'>)</span>
</pre>
Second of two Random Number Generators:

<pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>boolrnd</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Double</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>Bool</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>boolrnd</span> <span class='hs-varid'>p</span> <span class='hs-keyglyph'>=</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-keyword'>do</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getStdRandom</span> <span class='hs-varid'>random</span>
<span class='hs-varop'>&gt;</span>      <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-varop'>&lt;=</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
</pre>
Each person is identified with an agent.
Each agent can have two states, potential or adopter alone:

<pre><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>data</span> <span class='hs-conid'>Person</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Person</span> <span class='hs-layout'>{</span> <span class='hs-varid'>personAgent</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Agent</span><span class='hs-layout'>,</span>
<span class='hs-varop'>&gt;</span>                        <span class='hs-varid'>personPotentialAdopter</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AgentState</span><span class='hs-layout'>,</span>
<span class='hs-varop'>&gt;</span>                        <span class='hs-varid'>personAdopter</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AgentState</span> <span class='hs-layout'>}</span>
</pre>
<pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>createPerson</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynamicsQueue</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Dynamics</span> <span class='hs-conid'>Person</span>              
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>createPerson</span> <span class='hs-varid'>q</span> <span class='hs-keyglyph'>=</span>    
<span class='hs-varop'>&gt;</span>   <span class='hs-keyword'>do</span> <span class='hs-varid'>agent</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newAgent</span> <span class='hs-varid'>q</span>
<span class='hs-varop'>&gt;</span>      <span class='hs-varid'>potentialAdopter</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newState</span> <span class='hs-varid'>agent</span>
<span class='hs-varop'>&gt;</span>      <span class='hs-varid'>adopter</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newState</span> <span class='hs-varid'>agent</span>
<span class='hs-varop'>&gt;</span>      <span class='hs-varid'>return</span> <span class='hs-conid'>Person</span> <span class='hs-layout'>{</span> <span class='hs-varid'>personAgent</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>agent</span><span class='hs-layout'>,</span>
<span class='hs-varop'>&gt;</span>                      <span class='hs-varid'>personPotentialAdopter</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>potentialAdopter</span><span class='hs-layout'>,</span>
<span class='hs-varop'>&gt;</span>                      <span class='hs-varid'>personAdopter</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>adopter</span> <span class='hs-layout'>}</span>
</pre>
Given event queue, returning array:

<pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>createPersons</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynamicsQueue</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Dynamics</span> <span class='hs-layout'>(</span><span class='hs-conid'>Array</span> <span class='hs-conid'>Int</span> <span class='hs-conid'>Person</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>createPersons</span> <span class='hs-varid'>q</span> <span class='hs-keyglyph'>=</span>
</pre>
Create 500 (`n = 500`, given above) persons (next see `createPerson`):

<pre><span class='hs-varop'>&gt;</span>   <span class='hs-keyword'>do</span> <span class='hs-varid'>list</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>forM</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>1</span> <span class='hs-keyglyph'>..</span> <span class='hs-varid'>n</span><span class='hs-keyglyph'>]</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>i</span> <span class='hs-keyglyph'>-&gt;</span>
<span class='hs-varop'>&gt;</span>        <span class='hs-keyword'>do</span> <span class='hs-varid'>p</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>createPerson</span> <span class='hs-varid'>q</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>i</span><span class='hs-layout'>,</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span>      <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> <span class='hs-varid'>array</span> <span class='hs-layout'>(</span><span class='hs-num'>1</span><span class='hs-layout'>,</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-varid'>list</span>
</pre>
<pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>definePerson</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Person</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Array</span> <span class='hs-conid'>Int</span> <span class='hs-conid'>Person</span> 
<span class='hs-varop'>&gt;</span>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DynamicsRef</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DynamicsRef</span> <span class='hs-conid'>Int</span>
<span class='hs-varop'>&gt;</span>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Dynamics</span> <span class='hs-conid'>()</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>definePerson</span> <span class='hs-varid'>p</span> <span class='hs-varid'>ps</span> <span class='hs-varid'>potentialAdopters</span> <span class='hs-varid'>adopters</span> <span class='hs-keyglyph'>=</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-keyword'>do</span> <span class='hs-varid'>stateActivation</span> <span class='hs-layout'>(</span><span class='hs-varid'>personPotentialAdopter</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
</pre>
... `personPotentialAdopter` state of the agent `p` can be activated with the help of this...
How? Increase number of agents having `personPotentialAdopter` state. State activation is executed at time of its call as part of this monadic computation.

<pre><span class='hs-varop'>&gt;</span>        <span class='hs-keyword'>do</span> <span class='hs-varid'>modifyRef'</span> <span class='hs-varid'>potentialAdopters</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-varop'>+</span> <span class='hs-num'>1</span>
</pre>
In this monadic computation add a timeout, "making the agent alive"
first compute a time period in which the added timeout can be actuated

<pre><span class='hs-varop'>&gt;</span>           <span class='hs-varid'>t</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>liftIO</span> <span class='hs-varop'>$</span> <span class='hs-varid'>exprnd</span> <span class='hs-varid'>advertisingEffectiveness</span> 
<span class='hs-varop'>&gt;</span>           <span class='hs-keyword'>let</span> <span class='hs-varid'>st</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>personPotentialAdopter</span> <span class='hs-varid'>p</span>
<span class='hs-varop'>&gt;</span>               <span class='hs-varid'>st'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>personAdopter</span> <span class='hs-varid'>p</span>
</pre>
The handler (timeout) is given (as arguments) the state (`personPotentialAdopter`) it is assigned
to, the time period in which it can be actuated (the timeout is delayed - being stored in the event queue) - if `personPotentialAdopter` (the state)
will remain active and the third argument defines the corresponded computation
(which literally is "activate the `personAdopter` state")

If this handler is still actuated it happens only once as opposed to timer,
... does making sense as the transition to adopter is a one-step.

<pre><span class='hs-varop'>&gt;</span>           <span class='hs-varid'>addTimeout</span> <span class='hs-varid'>st</span> <span class='hs-varid'>t</span> <span class='hs-varop'>$</span> <span class='hs-varid'>activateState</span> <span class='hs-varid'>st'</span>
<span class='hs-varop'>&gt;</span>      <span class='hs-varid'>stateActivation</span> <span class='hs-layout'>(</span><span class='hs-varid'>personAdopter</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> 
</pre>
... `personAdopter` state of the agent `p` can be activated with the help of this...
How? Increase number of agents having `personAdopter` state, in case of success
(is what means "monadic" in this case of a computation) of the overall subsequent computation,
by updating the event queue ref. State activation is executed at time of its call as part of this monadic computation.

<pre><span class='hs-varop'>&gt;</span>        <span class='hs-keyword'>do</span> <span class='hs-varid'>modifyRef'</span> <span class='hs-varid'>adopters</span>  <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-varop'>+</span> <span class='hs-num'>1</span>
</pre>
In this monadic computation add a timer that works while the state is active,
"making the agent alive", the timer is assigned to the `personAdopter` state,
can be actuated within time period `t` and has the corresponded compuation defined
in the nested `do`... (next see *+) - timer is delayed in other terms - being stored in the event queue

Will periodically repeat while the (`personAdopter`) state remains active.

<pre><span class='hs-varop'>&gt;</span>           <span class='hs-keyword'>let</span> <span class='hs-varid'>t</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>liftIO</span> <span class='hs-varop'>$</span> <span class='hs-varid'>exprnd</span> <span class='hs-varid'>contactRate</span>    <span class='hs-comment'>-- many times!</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-varid'>addTimerD</span> <span class='hs-layout'>(</span><span class='hs-varid'>personAdopter</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span> <span class='hs-varid'>t</span> <span class='hs-varop'>$</span>
</pre>
`i` is the number of any one of 500 (amount of agents `n`, defined above) persons:

<pre><span class='hs-varop'>&gt;</span>             <span class='hs-keyword'>do</span> <span class='hs-varid'>i</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>liftIO</span> <span class='hs-varop'>$</span> <span class='hs-varid'>getStdRandom</span> <span class='hs-varop'>$</span> <span class='hs-varid'>randomR</span> <span class='hs-layout'>(</span><span class='hs-num'>1</span><span class='hs-layout'>,</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span>
</pre>
*+ the compuation corresponded to the timer handler.
Take the `i`th person number from the array:

<pre><span class='hs-varop'>&gt;</span>                <span class='hs-keyword'>let</span> <span class='hs-varid'>p'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ps</span> <span class='hs-varop'>!</span> <span class='hs-varid'>i</span>
</pre>
Determine the agent's (belonging to the drawn person number) "downmost active" state (as `st`):

<pre><span class='hs-varop'>&gt;</span>                <span class='hs-varid'>st</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>agentState</span> <span class='hs-layout'>(</span><span class='hs-varid'>personAgent</span> <span class='hs-varid'>p'</span><span class='hs-layout'>)</span>
</pre>
When the "downmost active" state is `personPotentialAdopter`...

<pre><span class='hs-varop'>&gt;</span>                <span class='hs-varid'>when</span> <span class='hs-layout'>(</span><span class='hs-varid'>st</span> <span class='hs-varop'>==</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>personPotentialAdopter</span> <span class='hs-varid'>p'</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
</pre>
... determine if/or not this agent should belong the `adopters`
this is a bool (named `b`) now, so there is a fifty-fifty chance...
... in other words an agent being currently a potential adopter has a
fifty-fifty chance now to belong to the `adopters` (or adopters fraction of the
500 consumers) by state activation in a moment... AARGH yet too complicated to even spell

<pre><span class='hs-varop'>&gt;</span>                  <span class='hs-keyword'>do</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>liftIO</span> <span class='hs-varop'>$</span> <span class='hs-varid'>boolrnd</span> <span class='hs-varid'>adoptionFraction</span>
</pre>
event queue won't be updated if not...

<pre><span class='hs-varop'>&gt;</span>                     <span class='hs-varid'>when</span> <span class='hs-varid'>b</span> <span class='hs-varop'>$</span> <span class='hs-varid'>activateState</span> <span class='hs-layout'>(</span><span class='hs-varid'>personAdopter</span> <span class='hs-varid'>p'</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span>      <span class='hs-varid'>stateDeactivation</span> <span class='hs-layout'>(</span><span class='hs-varid'>personPotentialAdopter</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
</pre>
... `personPotentialAdopter` state of the agent `p` can be deactivated with the help of this...
How? Simply decrease number of agents having `personPotentialAdopter` state,
updating the event queue ref. Effect: All handlers (timer, timeout) are outdated and will be ignored
but may be assigned new ones at time of next state activation

<pre><span class='hs-varop'>&gt;</span>       <span class='hs-varid'>modifyRef'</span> <span class='hs-varid'>potentialAdopters</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-comment'>-</span> <span class='hs-num'>1</span>
<span class='hs-varop'>&gt;</span>      <span class='hs-varid'>stateDeactivation</span> <span class='hs-layout'>(</span><span class='hs-varid'>personAdopter</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
</pre>
... `personAdopter` state of the agent `p` can be deactivated with the help of this...
How? Simply decrease number of agents having `personAdopter` state, updating the event queue
ref. Effect: All handlers (timer, timeout) are outdated and will be ignored
but may be assigned new ones at time of next state activation

<pre><span class='hs-varop'>&gt;</span>       <span class='hs-varid'>modifyRef'</span> <span class='hs-varid'>adopters</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-comment'>-</span> <span class='hs-num'>1</span>
</pre>
Given the persons array and the event queue refs to potential and real adopters,
prepare the `Dynamics` computation, next see `definePerson`, where the real `Dynamics` computation,
composed of activation and deactivation computations as well as timer and timeout handlers
is defined:

<pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>definePersons</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Array</span> <span class='hs-conid'>Int</span> <span class='hs-conid'>Person</span> 
<span class='hs-varop'>&gt;</span>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DynamicsRef</span> <span class='hs-conid'>Int</span> 
<span class='hs-varop'>&gt;</span>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DynamicsRef</span> <span class='hs-conid'>Int</span> 
<span class='hs-varop'>&gt;</span>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Dynamics</span> <span class='hs-conid'>()</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>definePersons</span> <span class='hs-varid'>ps</span> <span class='hs-varid'>potentialAdopters</span> <span class='hs-varid'>adopters</span> <span class='hs-keyglyph'>=</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-varid'>forM_</span> <span class='hs-layout'>(</span><span class='hs-varid'>elems</span> <span class='hs-varid'>ps</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>p</span> <span class='hs-keyglyph'>-&gt;</span> 
<span class='hs-varop'>&gt;</span>   <span class='hs-varid'>definePerson</span> <span class='hs-varid'>p</span> <span class='hs-varid'>ps</span> <span class='hs-varid'>potentialAdopters</span> <span class='hs-varid'>adopters</span>
</pre>
"Initiating agent and selecting another downmost active state" (state machine
approach to agents, see the ABM explanation in David Sorokin's paper - link at top of this page),
because its a product diffusion model, activating the
`personPotentialAdopter` state of the person always first:

<pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>activatePerson</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Person</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Dynamics</span> <span class='hs-conid'>()</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>activatePerson</span> <span class='hs-varid'>p</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>activateState</span> <span class='hs-layout'>(</span><span class='hs-varid'>personPotentialAdopter</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
</pre>
Run through the array, activating agents:

<pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>activatePersons</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Array</span> <span class='hs-conid'>Int</span> <span class='hs-conid'>Person</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Dynamics</span> <span class='hs-conid'>()</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>activatePersons</span> <span class='hs-varid'>ps</span> <span class='hs-keyglyph'>=</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-varid'>forM_</span> <span class='hs-layout'>(</span><span class='hs-varid'>elems</span> <span class='hs-varid'>ps</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>p</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>activatePerson</span> <span class='hs-varid'>p</span>
</pre>
<pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>model</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Dynamics</span> <span class='hs-layout'>(</span><span class='hs-conid'>Dynamics</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>model</span> <span class='hs-keyglyph'>=</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-keyword'>do</span> <span class='hs-varid'>q</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newQueue</span>
</pre>
An agent (representing consumers) can be in two states,
   potential adopter or

<pre><span class='hs-varop'>&gt;</span>      <span class='hs-varid'>potentialAdopters</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newRef</span> <span class='hs-varid'>q</span> <span class='hs-num'>0</span> <span class='hs-comment'>-- empty event queue</span>
</pre>
   adopter

<pre><span class='hs-varop'>&gt;</span>      <span class='hs-varid'>adopters</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newRef</span> <span class='hs-varid'>q</span> <span class='hs-num'>0</span>          <span class='hs-comment'>-- empty event queue</span>
</pre>
To create the person, we need the event queue (`q`).
We place all persons in the array (`ps`, next see `createPersons`)
We need this array to have an access to random agents at time when the
specified adopter tries to convert somebody to be an adopter too

<pre><span class='hs-varop'>&gt;</span>      <span class='hs-varid'>ps</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>createPersons</span> <span class='hs-varid'>q</span>
</pre>
Create the agents/objects and define their activation and deactivation
computations (next see `definePersons`)

<pre><span class='hs-varop'>&gt;</span>      <span class='hs-varid'>definePersons</span> <span class='hs-varid'>ps</span> <span class='hs-varid'>potentialAdopters</span> <span class='hs-varid'>adopters</span>
</pre>
Activate the agents in the array each, remember the lazy approach, this is
preparation all, executed only when the event queue reference is read

<pre><span class='hs-varop'>&gt;</span>      <span class='hs-varid'>activatePersons</span> <span class='hs-varid'>ps</span>
</pre>
Return pair (per simulation step?!!) expressing amount of potential
adopters remaining and adopters already existent, reading each entry from the
particular event queue reference (`potentialAdopters`, `adopters`)

<pre><span class='hs-varop'>&gt;</span>      <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> <span class='hs-keyword'>do</span> <span class='hs-varid'>i1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>readRef</span> <span class='hs-varid'>potentialAdopters</span>
<span class='hs-varop'>&gt;</span>                  <span class='hs-varid'>i2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>readRef</span> <span class='hs-varid'>adopters</span>
<span class='hs-varop'>&gt;</span>                  <span class='hs-varid'>return</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>i1</span><span class='hs-layout'>,</span> <span class='hs-varid'>i2</span><span class='hs-keyglyph'>]</span>
</pre>
David sent me the following comment: Also I think that it will be useful to show the results for this task lazily. It is possible with help of the `runDynamicsIO` function. It is especially useful if the number of agents is great. We can see how the performance is noticeably decreases when many agents become adopters.

<pre><span class='hs-varop'>&gt;</span> <span class='hs-comment'>-- | Show the simulation results lazily, one by one.</span>
<span class='hs-varop'>&gt;</span> <span class='hs-comment'>-- in main change: do xs &lt;- runDynamics model specs</span>
<span class='hs-varop'>&gt;</span> <span class='hs-comment'>-- to            : do xs &lt;- printDynamics model specs</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>printDynamics</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Show</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Dynamics</span> <span class='hs-layout'>(</span><span class='hs-conid'>Dynamics</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Specs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>printDynamics</span> <span class='hs-varid'>m</span> <span class='hs-varid'>specs</span> <span class='hs-keyglyph'>=</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-keyword'>do</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>runDynamicsIO</span> <span class='hs-varid'>m</span> <span class='hs-varid'>specs</span>
<span class='hs-varop'>&gt;</span>      <span class='hs-varid'>loop</span> <span class='hs-varid'>xs</span>
<span class='hs-varop'>&gt;</span>        <span class='hs-keyword'>where</span>
<span class='hs-varop'>&gt;</span>          <span class='hs-varid'>loop</span> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<span class='hs-varop'>&gt;</span>          <span class='hs-varid'>loop</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-conop'>:</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>x</span><span class='hs-layout'>;</span> <span class='hs-varid'>print</span> <span class='hs-varid'>a</span><span class='hs-layout'>;</span> <span class='hs-varid'>loop</span> <span class='hs-varid'>xs</span> <span class='hs-layout'>}</span>
</pre>

<pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>main</span> <span class='hs-keyglyph'>=</span>
</pre>
Start here (specs defined above, next see `model`).
Running the model means - "creating a simulation and then running it
in all integration time points using the specified simulation steps"
- in aivikas terms

(`runDynamics :: Dynamics (Dynamics a) -> Specs -> IO [a]`)

<pre><span class='hs-varop'>&gt;</span>   <span class='hs-keyword'>do</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>runDynamics</span> <span class='hs-varid'>model</span> <span class='hs-varid'>specs</span>
</pre>
For the above concrete specification (80 steps in 8 time points) yielding 81 pairs,
the initial pair included.

<pre><span class='hs-varop'>&gt;</span>      <span class='hs-varid'>print</span> <span class='hs-varid'>xs</span>
</pre>
</body>
</html>
